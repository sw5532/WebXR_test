<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Minimalist Depth Request</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #ar-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #glCanvas { width: 100%; height: 100%; z-index: -1; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none; z-index: 1; }
        #info-box, #start-button { pointer-events: auto; }
        #info-box { margin: 20px; padding: 10px; background: rgba(0,0,0,0.7); color: white; border-radius: 8px; }
        #start-button { margin: 20px auto; padding: 12px 24px; border: none; background-color: #007bff; color: white; border-radius: 8px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ar-container"><canvas id="glCanvas"></canvas></div>
    <div id="overlay">
        <div id="info-box">
            <div>Status: <span id="status">Ready</span></div>
            <div>Depth: <span id="depth-display">N/A</span></div>
        </div>
        <button id="start-button">Start AR</button>
    </div>

    <!-- Shaders are identical -->
    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec2 a_position; varying vec2 v_texcoord;
      void main() { gl_Position = vec4(a_position, 0.0, 1.0); v_texcoord = a_position * 0.5 + 0.5; v_texcoord.y = 1.0 - v_texcoord.y; }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float; uniform sampler2D u_depthTexture; varying vec2 v_texcoord;
      void main() {
        float dv = texture2D(u_depthTexture, v_texcoord).r; if (dv == 0.0) { discard; }
        float v = clamp(1.0 - dv / 5.0, 0.0, 1.0); gl_FragColor = vec4(1,1,1, v*0.5);
      }
    </script>

    <script>
    const startButton = document.getElementById('start-button'), statusEl = document.getElementById('status'), depthEl = document.getElementById('depth-display'), overlayEl = document.getElementById('overlay'), glCanvas = document.getElementById('glCanvas');
    let xrSession = null, gl = null, xrReferenceSpace = null, shaderProgram, positionBuffer, depthTextureUniform, hasDepthFeature = false;
    document.addEventListener('DOMContentLoaded', () => { if (!navigator.xr) { statusEl.textContent = "WebXR not supported."; startButton.disabled = true; return; } startButton.addEventListener('click', onStartButtonClick); });
    function onStartButtonClick() { if (xrSession) { xrSession.end(); } else { if (window.location.protocol !== 'https:') { statusEl.textContent = "WebXR requires HTTPS."; return; } initializeXR(); } }

    async function initializeXR() {
        statusEl.textContent = "Initializing WebGL...";
        if (!initializeWebGL()) return;
        try {
            statusEl.textContent = "Requesting AR session...";
            // *** THE ONLY CHANGE IS HERE: A simplified depthSensing block ***
            const session = await navigator.xr.requestSession("immersive-ar", {
                requiredFeatures: ['local'],
                optionalFeatures: ['dom-overlay', 'depth-sensing'],
            });
            onSessionStarted(session);
        } catch (error) { console.error("WebXR session request failed:", error); statusEl.textContent = `Error: ${error.message}`; }
    }
    
    // All other functions (initializeWebGL, onSessionStarted, onSessionEnded, onXRFrame, and helpers) are identical to the previous "robust" version.
    // I've included them here for completeness.
    
    function initializeWebGL() { try { gl = glCanvas.getContext('webgl', { xrCompatible: true }); gl.clearColor(0,0,0,0); const vs = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').textContent); const fs = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').textContent); shaderProgram = createProgram(gl, vs, fs); depthTextureUniform = gl.getUniformLocation(shaderProgram, 'u_depthTexture'); const pa = gl.getAttribLocation(shaderProgram, "a_position"); positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW); gl.enableVertexAttribArray(pa); gl.vertexAttribPointer(pa, 2, gl.FLOAT, false, 0, 0); return true; } catch (e) { console.error(e); statusEl.textContent = "WebGL Init Failed."; return false; } }
    async function onSessionStarted(session) { xrSession = session; startButton.textContent = "Exit AR"; session.addEventListener('end', onSessionEnded); if (session.depthUsage) { hasDepthFeature = true; statusEl.textContent = `AR Active | Depth: ${session.depthUsage}`; console.log("Depth Sensing is available and enabled."); } else { hasDepthFeature = false; statusEl.textContent = "AR Active (No Depth Support)"; depthEl.textContent = "Not supported on this device."; console.warn("Depth Sensing feature was requested but is not available."); } const glLayer = new XRWebGLLayer(xrSession, gl, { alpha: true }); await xrSession.updateRenderState({ baseLayer: glLayer }); xrReferenceSpace = await xrSession.requestReferenceSpace('local'); xrSession.requestAnimationFrame(onXRFrame); }
    function onSessionEnded() { xrSession = null; statusEl.textContent = "Ready"; startButton.textContent = "Start AR"; depthEl.textContent = "N/A"; hasDepthFeature = false; }
    function onXRFrame(time, frame) { if (!xrSession) return; xrSession.requestAnimationFrame(onXRFrame); const pose = frame.getViewerPose(xrReferenceSpace); if (!pose) return; const glLayer = xrSession.renderState.baseLayer; gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); if (hasDepthFeature) { const view = pose.views[0]; if (view) { const depthInfo = frame.getDepthInformation(view); if (depthInfo) { const cx = Math.floor(depthInfo.width/2), cy = Math.floor(depthInfo.height/2); const d = depthInfo.getDepthInMeters(cx, cy); depthEl.textContent = `${d.toFixed(2)}m`; const dt = glLayer.getDepthInformation(view).texture; gl.useProgram(shaderProgram); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, dt); gl.uniform1i(depthTextureUniform, 0); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); } else { depthEl.textContent = "Initializing..."; } } } }
    function createShader(gl, type, source) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { throw new Error(gl.getShaderInfoLog(s)); } return s; }
    function createProgram(gl, vs, fs) { const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { throw new Error(gl.getProgramInfoLog(p)); } return p; }
    </script>
</body>
</html>