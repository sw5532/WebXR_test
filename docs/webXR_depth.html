<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR Depth Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #glCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-family: sans-serif;
    }
    #startButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      padding: 12px 24px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <div id="info">
    <div id="depthDisplay">Depth at center: N/A</div>
    <div id="status">Click "Start AR" to begin</div>
  </div>
  <button id="startButton">Start AR</button>

  <!-- Vertex Shader: Renders a simple quad -->
  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_texcoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texcoord = a_position * 0.5 + 0.5;
      v_texcoord.y = 1.0 - v_texcoord.y;
    }
  </script>

  <!-- Fragment Shader: Visualizes the depth texture -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_depthTexture;
    varying vec2 v_texcoord;

    void main() {
      // The depth value is often packed into the red and alpha channels
      vec2 packedDepth = texture2D(u_depthTexture, v_texcoord).ra;
      float depth = dot(packedDepth, vec2(1.0, 255.0)); // Unpack the 16-bit depth
      
      // Visualize depth: further distances are darker
      float grey = 1.0 - clamp(depth / 10.0, 0.0, 1.0); // Adjust '10.0' for depth range
      gl_FragColor = vec4(grey, grey, grey, 1.0);
    }
  </script>

  <script>
    const startButton = document.getElementById('startButton');
    const depthDisplay = document.getElementById('depthDisplay');
    const statusDisplay = document.getElementById('status');
    const glCanvas = document.getElementById('glCanvas');

    let xrSession = null;
    let gl = null;
    let xrReferenceSpace = null;
    let shaderProgram;
    let positionBuffer;
    let depthTextureUniform;

    function initWebGL() {
      gl = glCanvas.getContext('webgl', { xrCompatible: true });
      if (!gl) {
        statusDisplay.textContent = 'WebGL is not supported.';
        return false;
      }

      const vsSource = document.getElementById('vertex-shader').textContent;
      const fsSource = document.getElementById('fragment-shader').textContent;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      shaderProgram = createProgram(gl, vertexShader, fragmentShader);

      depthTextureUniform = gl.getUniformLocation(shaderProgram, 'u_depthTexture');
      const positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      
      return true;
    }

    startButton.addEventListener('click', async () => {
      if (xrSession) {
        xrSession.end();
      } else {
        if (initWebGL()) {
          activateXR();
        }
      }
    });
    
    async function activateXR() {
      try {
        // Requesting the session with 'depth-sensing' as a required feature
        xrSession = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ['local', 'depth-sensing'],
          depthSensing: { // Specify preferences for depth data
            usagePreference: ['cpu-optimized'],
            dataFormatPreference: ['luminance-alpha']
          }
        });

        statusDisplay.textContent = 'AR Session Started';
        startButton.textContent = 'Exit AR';

        xrSession.addEventListener('end', () => {
          xrSession = null;
          startButton.textContent = 'Start AR';
          statusDisplay.textContent = 'Click "Start AR" to begin';
          depthDisplay.textContent = 'Depth at center: N/A';
        });

        await xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });
        xrReferenceSpace = await xrSession.requestReferenceSpace('local');
        
        xrSession.requestAnimationFrame(onXRFrame);

      } catch (e) {
        console.error("Failed to start AR session:", e);
        statusDisplay.textContent = `Error: ${e.message}`;
      }
    }

    function onXRFrame(time, frame) {
      if (!xrSession) return;
      
      xrSession.requestAnimationFrame(onXRFrame);
      
      const pose = frame.getViewerPose(xrReferenceSpace);
      if (!pose) return;

      const glLayer = xrSession.renderState.baseLayer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      for (const view of pose.views) {
        const viewport = glLayer.getViewport(view);
        gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

        const depthInfo = frame.getDepthInformation(view);
        if (depthInfo) {
          // --- Depth Value Display ---
          const centerX = depthInfo.width / 2;
          const centerY = depthInfo.height / 2;
          const depthInMeters = depthInfo.getDepthInMeters(centerX, centerY);
          if (depthInMeters) {
            depthDisplay.textContent = `Depth at center: ${depthInMeters.toFixed(2)}m`;
          }

          // --- WebGL Depth Visualization ---
          const depthTexture = glLayer.getDepthInformation(view).texture;

          gl.useProgram(shaderProgram);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, depthTexture);
          gl.uniform1i(depthTextureUniform, 0);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          
        } else {
          depthDisplay.textContent = 'Depth not available for this frame.';
        }
      }
    }

    // --- WebGL Helper Functions ---
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }
  </script>
</body>
</html>