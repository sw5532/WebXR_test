<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Depth Debugging</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #ar-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #glCanvas { width: 100%; height: 100%; z-index: -1; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; z-index: 1;
        }
        #info-box, #start-button { pointer-events: auto; }
        #info-box { margin: 20px; padding: 10px; background: rgba(0,0,0,0.7); color: white; border-radius: 8px; }
        #start-button { margin: 20px auto; padding: 12px 24px; border: none; background-color: #007bff; color: white; border-radius: 8px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ar-container">
        <canvas id="glCanvas"></canvas>
    </div>

    <div id="overlay">
        <div id="info-box">
            <div>Status: <span id="status">Ready</span></div>
            <div>Depth: <span id="depth-display">N/A</span></div>
        </div>
        <button id="start-button">Start AR</button>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec2 a_position;
      varying vec2 v_texcoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texcoord = a_position * 0.5 + 0.5;
        v_texcoord.y = 1.0 - v_texcoord.y; // Flip Y for texture coordinates
      }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;
      uniform sampler2D u_depthTexture;
      varying vec2 v_texcoord;
      void main() {
        float depthValue = texture2D(u_depthTexture, v_texcoord).r;
        if (depthValue == 0.0) {
            discard; // Don't draw where there's no depth data
        }
        // Visualize depth: closer is brighter white, fading to transparent
        float visibility = clamp(1.0 - depthValue / 5.0, 0.0, 1.0);
        gl_FragColor = vec4(1.0, 1.0, 1.0, visibility * 0.5);
      }
    </script>

    <script>
    const startButton = document.getElementById('start-button');
    const statusEl = document.getElementById('status');
    const depthEl = document.getElementById('depth-display');
    const overlayEl = document.getElementById('overlay');
    const glCanvas = document.getElementById('glCanvas');

    let xrSession = null;
    let gl = null;
    let xrReferenceSpace = null;
    let shaderProgram;
    let positionBuffer;
    let depthTextureUniform;

    // --- Main Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        if (!navigator.xr) {
            statusEl.textContent = "WebXR not supported by this browser.";
            startButton.disabled = true;
            return;
        }
        startButton.addEventListener('click', onStartButtonClick);
    });

    function onStartButtonClick() {
        if (xrSession) {
            xrSession.end().catch(err => console.error("Session end failed:", err));
        } else {
            // Check for HTTPS
            if (window.location.protocol !== 'https:') {
                statusEl.textContent = "WebXR requires HTTPS. Please serve your page securely.";
                return;
            }
            initializeXR();
        }
    }

    async function initializeXR() {
        statusEl.textContent = "Initializing WebGL...";
        if (!initializeWebGL()) return;

        try {
            statusEl.textContent = "Requesting AR session...";
            const session = await navigator.xr.requestSession("immersive-ar", {
                requiredFeatures: ['local', 'depth-sensing'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: overlayEl },
                depthSensing: {
                    usagePreference: ["cpu-optimized", "gpu-optimized"],
                    dataFormatPreference: ["luminance-alpha", "float32"]
                }
            });

            onSessionStarted(session);
        } catch (error) {
            console.error("WebXR session request failed:", error);
            statusEl.textContent = `Error: ${error.message}. Check browser support and permissions.`;
        }
    }

    function initializeWebGL() {
        try {
            gl = glCanvas.getContext('webgl', { xrCompatible: true });
            gl.clearColor(0.0, 0.0, 0.0, 0.0); // Transparent background

            const vs = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').textContent);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').textContent);
            shaderProgram = createProgram(gl, vs, fs);

            depthTextureUniform = gl.getUniformLocation(shaderProgram, 'u_depthTexture');
            const posAttrib = gl.getAttribLocation(shaderProgram, "a_position");

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(posAttrib);
            gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);

            return true;
        } catch (error) {
            console.error("WebGL initialization failed:", error);
            statusEl.textContent = "Failed to initialize WebGL.";
            return false;
        }
    }

    async function onSessionStarted(session) {
        xrSession = session;
        statusEl.textContent = "AR Session active.";
        startButton.textContent = "Exit AR";

        session.addEventListener('end', onSessionEnded);

        const glLayer = new XRWebGLLayer(xrSession, gl, { alpha: true });
        await xrSession.updateRenderState({ baseLayer: glLayer });

        xrReferenceSpace = await xrSession.requestReferenceSpace('local');
        xrSession.requestAnimationFrame(onXRFrame);
    }

    function onSessionEnded() {
        xrSession = null;
        statusEl.textContent = "Ready";
        startButton.textContent = "Start AR";
        depthEl.textContent = "N/A";
        console.log("WebXR session ended.");
    }

    function onXRFrame(time, frame) {
        if (!xrSession) return;
        xrSession.requestAnimationFrame(onXRFrame);

        const pose = frame.getViewerPose(xrReferenceSpace);
        if (!pose) return;

        const glLayer = xrSession.renderState.baseLayer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for (const view of pose.views) {
            const depthInfo = frame.getDepthInformation(view);
            if (depthInfo) {
                // Display depth value from the center of the view
                const centerX = Math.floor(depthInfo.width / 2);
                const centerY = Math.floor(depthInfo.height / 2);
                const depthInMeters = depthInfo.getDepthInMeters(centerX, centerY);
                depthEl.textContent = `${depthInMeters.toFixed(2)}m`;

                // Get the depth texture from the GPU
                const depthTexture = glLayer.getDepthInformation(view).texture;

                // Render the depth visualization
                gl.useProgram(shaderProgram);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, depthTexture);
                gl.uniform1i(depthTextureUniform, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            } else {
                depthEl.textContent = "Not available";
            }
        }
    }

    // --- WebGL Helper Functions ---
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
        }
        return shader;
    }
    function createProgram(gl, vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
        }
        return program;
    }
    </script>
</body>
</html>