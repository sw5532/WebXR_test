<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR Depth Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* The canvas will be under the DOM overlay */
    #glCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

    /* This container will hold all visible UI elements */
    #dom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none; /* Allows clicks to pass through to the canvas if needed */
    }

    #info {
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      margin: 10px;
      font-family: sans-serif;
      pointer-events: auto; /* Re-enable pointer events for this element */
    }

    #startButton {
      margin: 20px auto;
      padding: 12px 24px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      pointer-events: auto; /* Re-enable pointer events for the button */
    }
  </style>
</head>
<body>
  <!-- The WebGL canvas for rendering the depth visualization -->
  <canvas id="glCanvas"></canvas>

  <!-- This overlay will contain all the UI -->
  <div id="dom-overlay">
      <div id="info">
          <div id="status">Click "Start AR" to begin</div>
          <div id="depthDisplay">Depth at center: N/A</div>
      </div>
      <button id="startButton">Start AR</button>
  </div>

  <!-- Shaders (no changes needed here) -->
  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_texcoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texcoord = a_position * 0.5 + 0.5;
      v_texcoord.y = 1.0 - v_texcoord.y;
    }
  </script>
  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_depthTexture;
    varying vec2 v_texcoord;
    void main() {
      vec4 depthSample = texture2D(u_depthTexture, v_texcoord);
      // Using luminance-alpha, depth is in the first (red) channel.
      float depth = depthSample.r;
      // Visualize depth: closer is brighter, further is transparent
      float grey = clamp(1.0 - depth / 5.0, 0.0, 1.0); // Adjust '5.0' for range
      gl_FragColor = vec4(grey, grey, grey, grey); // Use the greyscale value for alpha
    }
  </script>

  <script>
    const startButton = document.getElementById('startButton');
    const depthDisplay = document.getElementById('depthDisplay');
    const statusDisplay = document.getElementById('status');
    const glCanvas = document.getElementById('glCanvas');
    const domOverlayRoot = document.getElementById('dom-overlay'); // Get the overlay root

    let xrSession = null;
    let gl = null;
    let xrReferenceSpace = null;
    let shaderProgram;
    let positionBuffer;
    let depthTextureUniform;

    function initWebGL() {
      gl = glCanvas.getContext('webgl', { xrCompatible: true });
      if (!gl) {
        statusDisplay.textContent = 'WebGL is not supported.';
        return false;
      }
      // *** CHANGE 1: Set a transparent clear color ***
      gl.clearColor(0.0, 0.0, 0.0, 0.0);

      const vsSource = document.getElementById('vertex-shader').textContent;
      const fsSource = document.getElementById('fragment-shader').textContent;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      shaderProgram = createProgram(gl, vertexShader, fragmentShader);

      depthTextureUniform = gl.getUniformLocation(shaderProgram, 'u_depthTexture');
      const positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      return true;
    }

    startButton.addEventListener('click', () => {
      if (xrSession) {
        xrSession.end();
      } else {
        if (initWebGL()) {
          activateXR();
        }
      }
    });

    async function activateXR() {
      try {
        // *** CHANGE 2: Request 'dom-overlay' and link it to your UI container ***
        xrSession = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ['local', 'depth-sensing'],
          optionalFeatures: ['dom-overlay'], // Request the DOM overlay feature
          domOverlay: { root: domOverlayRoot }, // Specify the root element
          depthSensing: {
            usagePreference: ["cpu-optimized"],
            dataFormatPreference: ["luminance-alpha"]
          }
        });

        statusDisplay.textContent = 'AR Session Started';
        startButton.textContent = 'Exit AR';
        domOverlayRoot.style.display = 'flex'; // Make sure overlay is visible

        xrSession.addEventListener('end', () => {
          xrSession = null;
          startButton.textContent = 'Start AR';
          statusDisplay.textContent = 'Click "Start AR" to begin';
          depthDisplay.textContent = 'Depth at center: N/A';
        });

        // *** CHANGE 3: Enable alpha when creating the XRWebGLLayer ***
        const glLayer = new XRWebGLLayer(xrSession, gl, { alpha: true });
        await xrSession.updateRenderState({ baseLayer: glLayer });
        xrReferenceSpace = await xrSession.requestReferenceSpace('local');

        xrSession.requestAnimationFrame(onXRFrame);

      } catch (e) {
        console.error("Failed to start AR session:", e);
        statusDisplay.textContent = `Error: ${e.message}`;
      }
    }

    function onXRFrame(time, frame) {
      if (!xrSession) return;
      xrSession.requestAnimationFrame(onXRFrame);

      const pose = frame.getViewerPose(xrReferenceSpace);
      if (!pose) return;

      const glLayer = xrSession.renderState.baseLayer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
      // This will now clear to transparent, allowing the camera to be seen
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      for (const view of pose.views) {
        const depthInfo = frame.getDepthInformation(view);
        if (depthInfo) {
          const centerX = depthInfo.width / 2;
          const centerY = depthInfo.height / 2;
          const depthInMeters = depthInfo.getDepthInMeters(centerX, centerY);
          depthDisplay.textContent = `Depth at center: ${depthInMeters.toFixed(2)}m`;

          const depthTexture = glLayer.getDepthInformation(view).texture;
          gl.useProgram(shaderProgram);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, depthTexture);
          gl.uniform1i(depthTextureUniform, 0);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    }

    // --- WebGL Helper Functions (no changes needed) ---
    function createShader(gl, type, source) { /* ... as before ... */ }
    function createProgram(gl, vertexShader, fragmentShader) { /* ... as before ... */ }
    // (I've omitted the helper function code for brevity, it's the same as the previous example)
  </script>
</body>
</html>